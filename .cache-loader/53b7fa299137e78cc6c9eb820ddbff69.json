{"remainingRequest":"/Users/andrewsamboy/Desktop/Git/polymail/webapp/node_modules/ts-loader/index.js??ref--6-1!/Users/andrewsamboy/Desktop/Git/polymail/webapp/src/lib/matcher.tsx","dependencies":[{"path":"/Users/andrewsamboy/Desktop/Git/polymail/webapp/src/lib/matcher.tsx","mtime":1675280254065},{"path":"/Users/andrewsamboy/Desktop/Git/polymail/webapp/node_modules/cache-loader/dist/cjs.js","mtime":1675365393858},{"path":"/Users/andrewsamboy/Desktop/Git/polymail/webapp/node_modules/ts-loader/index.js","mtime":1675365391714}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JzsKaW1wb3J0IHsgdHlwZWFoZWFkUmVnZXggfSBmcm9tICcuL3R5cGVhaGVhZCc7CmltcG9ydCB7IENvbW1hbmRDb250cm9sVHlwZSB9IGZyb20gJ0BzcmMvdHlwZXMnOwovLyBSZXR1cm5zIHJlc3VsdHMgb2Ygc29ydGVkIG1hdGNoZXMKLy8gT2JqZWN0S2V5IGlzIHRoZSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IHRoYXQgcmV0dXJucyB0aGUgc3RyaW5nIHZhbHVlIHRvIGJlIHNjb3JlZApleHBvcnQgdmFyIHNvcnRNYXRjaGVzID0gZnVuY3Rpb24gKGNhbmRpZGF0ZXMsIHF1ZXJ5LCBvYmplY3RLZXkpIHsKICAgIGlmICghcXVlcnkpIHsKICAgICAgICByZXR1cm4gY2FuZGlkYXRlczsKICAgIH0KICAgIC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBzY29yZWQgY2FuZGlkYXRlcwogICAgdmFyIHNjb3JlZENhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLm1hcChmdW5jdGlvbiAoY2FuZGlkYXRlKSB7CiAgICAgICAgdmFyIHNjb3JlID0gMDsKICAgICAgICBpZiAob2JqZWN0S2V5ICYmIGNhbmRpZGF0ZVtvYmplY3RLZXldKSB7CiAgICAgICAgICAgIHNjb3JlID0gZnV6enlNYXRjaChxdWVyeSwgY2FuZGlkYXRlW29iamVjdEtleV0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBjYW5kaWRhdGU6IGNhbmRpZGF0ZSwgc2NvcmU6IHNjb3JlIH07CiAgICB9KTsKICAgIHZhciBzb3J0ZWRDYW5kaWRhdGVzID0gc2NvcmVkQ2FuZGlkYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnNjb3JlIC0gYS5zY29yZTsgfSk7CiAgICByZXR1cm4gc29ydGVkQ2FuZGlkYXRlcy5tYXAoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmNhbmRpZGF0ZTsgfSk7Cn07CmV4cG9ydCB2YXIgc29ydEhvdGtleU1hdGNoZXMgPSBmdW5jdGlvbiAoY2FuZGlkYXRlcywgcXVlcnksIG9iamVjdEtleSkgewogICAgaWYgKCFxdWVyeSkgewogICAgICAgIHJldHVybiBjYW5kaWRhdGVzOwogICAgfQogICAgLy8gQ3JlYXRlIG9iamVjdCB3aXRoIHNjb3JlZCBjYW5kaWRhdGVzCiAgICB2YXIgc2NvcmVkQ2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMubWFwKGZ1bmN0aW9uIChjYW5kaWRhdGUpIHsKICAgICAgICB2YXIgc2NvcmUgPSAwOwogICAgICAgIGlmIChvYmplY3RLZXkgJiYgY2FuZGlkYXRlW29iamVjdEtleV0pIHsKICAgICAgICAgICAgc2NvcmUgPSBmdXp6eU1hdGNoKHF1ZXJ5LCBjYW5kaWRhdGVbb2JqZWN0S2V5XSk7CiAgICAgICAgfQogICAgICAgIC8vIEhBQ0soU0hJTik6IERlY3JlYXNlIHNjb3JlIGZvciBuYXZpZ2F0aW9uIGl0ZW1zCiAgICAgICAgaWYgKGNhbmRpZGF0ZS5zY29wZSAmJiBjYW5kaWRhdGUuc2NvcGUgPT09IENvbW1hbmRDb250cm9sVHlwZS5OYXZpZ2F0aW9uKSB7CiAgICAgICAgICAgIHNjb3JlID0gc2NvcmUgLSAxMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgY2FuZGlkYXRlOiBjYW5kaWRhdGUsIHNjb3JlOiBzY29yZSB9OwogICAgfSk7CiAgICB2YXIgc29ydGVkQ2FuZGlkYXRlcyA9IHNjb3JlZENhbmRpZGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi5zY29yZSAtIGEuc2NvcmU7IH0pOwogICAgcmV0dXJuIHNvcnRlZENhbmRpZGF0ZXMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5jYW5kaWRhdGU7IH0pOwp9OwovLyBSZXR1cm5zIHJlc3VsdHMgb2Ygc29ydGVkIG1hdGNoZXMKLy8gT2JqZWN0S2V5IGlzIHRoZSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IHRoYXQgcmV0dXJucyB0aGUgc3RyaW5nIHZhbHVlIHRvIGJlIHNjb3JlZApleHBvcnQgdmFyIHNvcnRTdHJpbmdNYXRjaGVzID0gZnVuY3Rpb24gKGNhbmRpZGF0ZXMsIHF1ZXJ5KSB7CiAgICBpZiAoIXF1ZXJ5KSB7CiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7CiAgICB9CiAgICAvLyBDcmVhdGUgb2JqZWN0IHdpdGggc2NvcmVkIGNhbmRpZGF0ZXMKICAgIHZhciBzY29yZWRDYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5tYXAoZnVuY3Rpb24gKGNhbmRpZGF0ZSkgewogICAgICAgIHZhciBzY29yZSA9IDA7CiAgICAgICAgc2NvcmUgPSBmdXp6eU1hdGNoKHF1ZXJ5LCBjYW5kaWRhdGUpOwogICAgICAgIHJldHVybiB7IGNhbmRpZGF0ZTogY2FuZGlkYXRlLCBzY29yZTogc2NvcmUgfTsKICAgIH0pOwogICAgdmFyIHNvcnRlZENhbmRpZGF0ZXMgPSBzY29yZWRDYW5kaWRhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIuc2NvcmUgLSBhLnNjb3JlOyB9KTsKICAgIHJldHVybiBzb3J0ZWRDYW5kaWRhdGVzLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuY2FuZGlkYXRlOyB9KTsKfTsKLy8gU2NvcmUgY29uc3RzCnZhciBhZGphY2VuY3lfYm9udXMgPSAxMDA7IC8vIGJvbnVzIGZvciBhZGphY2VudCBtYXRjaGVzCnZhciBzZXBhcmF0b3JfYm9udXMgPSA1MDsgLy8gYm9udXMgaWYgbWF0Y2ggb2NjdXJzIGFmdGVyIGEgc2VwYXJhdG9yCnZhciBsZWFkaW5nX2xldHRlcl9wZW5hbHR5ID0gLTAuNTsgLy8gcGVuYWx0eSBldmVyeSBsZXR0ZXIgaW4gc3RyIGJlZm9yZSB0aGUgZmlyc3QgbWF0Y2gKdmFyIG1heF9sZWFkaW5nX2xldHRlcl9wZW5hbHR5ID0gLTE7IC8vIG1heGltdW0gcGVuYWx0eSBmb3IgbGVhZGluZyBsZXR0ZXJzCnZhciB1bm1hdGNoZWRfbGV0dGVyX3BlbmFsdHkgPSAtMTsgLy8gcGVuYWx0eSBmb3IgZXZlcnkgbGV0dGVyIHRoYXQgZG9lc24ndCBtYXR0ZXIKLy8gUmV0dXJucyBbc2NvcmVdCi8vIHNjb3JlOiBpbnRlZ2VyOyBoaWdoZXIgaXMgYmV0dGVyIG1hdGNoLiBWYWx1ZSBoYXMgbm8gaW50cmluc2ljIG1lYW5pbmcuCi8vIFJhbmdlIHZhcmllcyB3aXRoIHBhdHRlcm4uIENhbiBvbmx5IGNvbXBhcmUgc2NvcmVzIHdpdGggc2FtZSBzZWFyY2ggcGF0dGVybi4KLy8gVmVuZG9yZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZm9ycmVzdHRoZXdvb2RzL2xpYl9mdHMKLy8gVE9ETyhTSElOKTogVGhlcmUgaXMgYSBuZXcgdmVuZG9yZWQgdmVyc2lvbiB3ZSBwcm9iYWJseSB3YW50IHRvIHVwZGF0ZSB0byB0aGF0IHVzZXMgcmVjdXJzaW9uCmZ1bmN0aW9uIGZ1enp5TWF0Y2gocGF0dGVybiwgc3RyKSB7CiAgICAvLyBMb29wIHZhcmlhYmxlcwogICAgdmFyIHNjb3JlID0gMDsKICAgIHZhciBwYXR0ZXJuSWR4ID0gMDsKICAgIHZhciBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7CiAgICB2YXIgc3RySWR4ID0gMDsKICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoOwogICAgdmFyIHByZXZNYXRjaGVkID0gZmFsc2U7CiAgICB2YXIgcHJldlNlcGFyYXRvciA9IHRydWU7IC8vIHRydWUgc28gaWYgZmlyc3QgbGV0dGVyIG1hdGNoIGdldHMgc2VwYXJhdG9yIGJvbnVzCiAgICB2YXIgcHJldlNlcGFyYXRvckluZGV4ID0gMDsKICAgIC8vIFVzZSAiYmVzdCIgbWF0Y2hlZCBsZXR0ZXIgaWYgbXVsdGlwbGUgc3RyaW5nIGxldHRlcnMgbWF0Y2ggdGhlIHBhdHRlcm4KICAgIHZhciBiZXN0TGV0dGVyID0gbnVsbDsKICAgIHZhciBiZXN0TG93ZXIgPSBudWxsOwogICAgdmFyIGJlc3RMZXR0ZXJJZHggPSBudWxsOwogICAgdmFyIGJlc3RMZXR0ZXJTY29yZSA9IDA7CiAgICB2YXIgbWF0Y2hlZEluZGljZXMgPSBbXTsKICAgIC8vIExvb3Agb3ZlciBzdHJpbmdzCiAgICB3aGlsZSAoc3RySWR4ICE9PSBzdHJMZW5ndGgpIHsKICAgICAgICB2YXIgcGF0dGVybkNoYXIgPSBwYXR0ZXJuSWR4ICE9PSBwYXR0ZXJuTGVuZ3RoID8gcGF0dGVybi5jaGFyQXQocGF0dGVybklkeCkgOiBudWxsOwogICAgICAgIHZhciBzdHJDaGFyID0gc3RyLmNoYXJBdChzdHJJZHgpOwogICAgICAgIHZhciBwYXR0ZXJuTG93ZXIgPSBwYXR0ZXJuQ2hhciAhPSBudWxsID8gcGF0dGVybkNoYXIudG9Mb3dlckNhc2UoKSA6IG51bGw7CiAgICAgICAgdmFyIHN0ckxvd2VyID0gc3RyQ2hhci50b0xvd2VyQ2FzZSgpOwogICAgICAgIHZhciBuZXh0TWF0Y2ggPSBwYXR0ZXJuQ2hhciAmJiBwYXR0ZXJuTG93ZXIgPT09IHN0ckxvd2VyOwogICAgICAgIHZhciByZW1hdGNoID0gYmVzdExldHRlciAmJiBiZXN0TG93ZXIgPT09IHN0ckxvd2VyOwogICAgICAgIHZhciBhZHZhbmNlZCA9IG5leHRNYXRjaCAmJiBiZXN0TGV0dGVyOwogICAgICAgIHZhciBwYXR0ZXJuUmVwZWF0ID0gYmVzdExldHRlciAmJiBwYXR0ZXJuQ2hhciAmJiBiZXN0TG93ZXIgPT09IHBhdHRlcm5Mb3dlcjsKICAgICAgICBpZiAoYWR2YW5jZWQgfHwgcGF0dGVyblJlcGVhdCkgewogICAgICAgICAgICBzY29yZSArPSBiZXN0TGV0dGVyU2NvcmU7CiAgICAgICAgICAgIGlmIChiZXN0TGV0dGVySWR4KSB7CiAgICAgICAgICAgICAgICBtYXRjaGVkSW5kaWNlcy5wdXNoKGJlc3RMZXR0ZXJJZHgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJlc3RMZXR0ZXIgPSBudWxsOwogICAgICAgICAgICBiZXN0TG93ZXIgPSBudWxsOwogICAgICAgICAgICBiZXN0TGV0dGVySWR4ID0gbnVsbDsKICAgICAgICAgICAgYmVzdExldHRlclNjb3JlID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKG5leHRNYXRjaCB8fCByZW1hdGNoKSB7CiAgICAgICAgICAgIHZhciBuZXdTY29yZSA9IDA7CiAgICAgICAgICAgIC8vIEFwcGx5IHBlbmFsdHkgZm9yIGVhY2ggbGV0dGVyIGJlZm9yZSB0aGUgZmlyc3QgcGF0dGVybiBtYXRjaAogICAgICAgICAgICAvLyBOb3RlOiBzdGQ6Om1heCBiZWNhdXNlIHBlbmFsdGllcyBhcmUgbmVnYXRpdmUgdmFsdWVzLiBTbyBtYXggaXMgc21hbGxlc3QgcGVuYWx0eS4KICAgICAgICAgICAgaWYgKHBhdHRlcm5JZHggPT09IDApIHsKICAgICAgICAgICAgICAgIHZhciBwZW5hbHR5ID0gTWF0aC5tYXgoc3RySWR4ICogbGVhZGluZ19sZXR0ZXJfcGVuYWx0eSwgbWF4X2xlYWRpbmdfbGV0dGVyX3BlbmFsdHkpOwogICAgICAgICAgICAgICAgc2NvcmUgKz0gcGVuYWx0eTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBBcHBseSBib251cyBmb3IgY29uc2VjdXRpdmUgYm9udXNlcwogICAgICAgICAgICBpZiAocHJldk1hdGNoZWQpIHsKICAgICAgICAgICAgICAgIG5ld1Njb3JlICs9IGFkamFjZW5jeV9ib251czsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBBcHBseSBib251cyBmb3IgbWF0Y2hlcyBhZnRlciBhIHNlcGFyYXRvcgogICAgICAgICAgICBpZiAocHJldlNlcGFyYXRvcikgewogICAgICAgICAgICAgICAgaWYgKHByZXZTZXBhcmF0b3JJbmRleCA+IDApIHsKICAgICAgICAgICAgICAgICAgICBuZXdTY29yZSArPSAoc2VwYXJhdG9yX2JvbnVzICsgMSAvIHByZXZTZXBhcmF0b3JJbmRleCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBuZXdTY29yZSArPSAoc2VwYXJhdG9yX2JvbnVzICogMyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gVXBkYXRlIHBhdHRlciBpbmRleCBJRkYgdGhlIG5leHQgcGF0dGVybiBsZXR0ZXIgd2FzIG1hdGNoZWQKICAgICAgICAgICAgaWYgKG5leHRNYXRjaCkgewogICAgICAgICAgICAgICAgcGF0dGVybklkeCArPSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIFVwZGF0ZSBiZXN0IGxldHRlciBpbiBzdHIgd2hpY2ggbWF5IGJlIGZvciBhICJuZXh0IiBsZXR0ZXIgb3IgYSAicmVtYXRjaCIKICAgICAgICAgICAgaWYgKG5ld1Njb3JlID49IGJlc3RMZXR0ZXJTY29yZSkgewogICAgICAgICAgICAgICAgLy8gQXBwbHkgcGVuYWx0eSBmb3Igbm93IHNraXBwZWQgbGV0dGVyCiAgICAgICAgICAgICAgICBpZiAoYmVzdExldHRlciAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgc2NvcmUgKz0gdW5tYXRjaGVkX2xldHRlcl9wZW5hbHR5OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYmVzdExldHRlciA9IHN0ckNoYXI7CiAgICAgICAgICAgICAgICBiZXN0TG93ZXIgPSBiZXN0TGV0dGVyLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgICBiZXN0TGV0dGVySWR4ID0gc3RySWR4OwogICAgICAgICAgICAgICAgYmVzdExldHRlclNjb3JlID0gbmV3U2NvcmU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcHJldk1hdGNoZWQgPSB0cnVlOwogICAgICAgIH0KICAgICAgICBlbHNlIHsgLy8gQXBwZW5kIHVubWF0Y2ggY2hhcmFjdGVycwogICAgICAgICAgICBzY29yZSArPSB1bm1hdGNoZWRfbGV0dGVyX3BlbmFsdHk7CiAgICAgICAgICAgIHByZXZNYXRjaGVkID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIC8vIEluY2x1ZGVzICJjbGV2ZXIiIGlzTGV0dGVyIGNoZWNrLgogICAgICAgIHByZXZTZXBhcmF0b3IgPSBzdHJDaGFyID09PSAnXycgfHwgc3RyQ2hhciA9PT0gJyAnIHx8IHN0ckNoYXIgPT09ICcvJzsKICAgICAgICBwcmV2U2VwYXJhdG9ySW5kZXggPSBzdHJJZHg7CiAgICAgICAgc3RySWR4ICs9IDE7CiAgICB9CiAgICAvLyBBcHBseSBzY29yZSBmb3IgbGFzdCBtYXRjaAogICAgaWYgKGJlc3RMZXR0ZXIgJiYgYmVzdExldHRlcklkeCkgewogICAgICAgIHNjb3JlICs9IGJlc3RMZXR0ZXJTY29yZTsKICAgIH0KICAgIC8vIEFkZCAxMDAwIGlmIHNjb3JlIGluY2x1ZGVzIGFuIGV4YWN0IG1hdGNoIGluIHRoZSBzdHJpbmcKICAgIGlmIChzdHIudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhwYXR0ZXJuKSkgewogICAgICAgIHNjb3JlICs9IDUwMDsKICAgIH0KICAgIHJldHVybiBzY29yZTsKfQpleHBvcnQgdmFyIGZ1enp5Rm9ybWF0dGVkU3RyaW5nID0gZnVuY3Rpb24gKHBhdHRlcm4sIHN0ciwga2V5SWR4KSB7CiAgICB2YXIgc2FuaXRpemVkUGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXHMrL2csICcnKTsKICAgIHZhciByZWdleCA9IHR5cGVhaGVhZFJlZ2V4KHNhbml0aXplZFBhdHRlcm4pOwogICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTsKICAgIHZhciBtYXRjaGVzID0gW107CiAgICBpZiAoc2FuaXRpemVkUGF0dGVybi5sZW5ndGggJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMCkgewogICAgICAgIHZhciB0aXRsZUxvd2VyY2FzZSA9IHN0ci50b0xvd2VyQ2FzZSgpOwogICAgICAgIHZhciBzYW5pdGl6ZWRQYXR0ZXJuTG93ZXJjYXNlID0gc2FuaXRpemVkUGF0dGVybi50b0xvd2VyQ2FzZSgpOwogICAgICAgIHZhciBzdGFydCA9IDA7CiAgICAgICAgdmFyIGVuZCA9IHRpdGxlTG93ZXJjYXNlLmluZGV4T2Yoc2FuaXRpemVkUGF0dGVybkxvd2VyY2FzZVswXSk7CiAgICAgICAgbWF0Y2hlcyA9IFsKICAgICAgICAgICAgc3RyLnNsaWNlKHN0YXJ0LCBlbmQpLAogICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCJzdHJvbmciLCB7IGtleToga2V5SWR4ICsgIi1zdHJvbmciIH0sIHN0cltlbmRdKSwKICAgICAgICBdOwogICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2FuaXRpemVkUGF0dGVybi5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICBzdGFydCA9IGVuZCArIDE7CiAgICAgICAgICAgIGVuZCA9IHRpdGxlTG93ZXJjYXNlLmluZGV4T2Yoc2FuaXRpemVkUGF0dGVybkxvd2VyY2FzZVtpXSwgc3RhcnQpOwogICAgICAgICAgICBtYXRjaGVzLnB1c2goc3RyLnNsaWNlKHN0YXJ0LCBlbmQpKTsKICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoInN0cm9uZyIsIG51bGwsIHN0cltlbmRdKSk7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgIT09IHN0ci5sZW5ndGggLSAxKSB7CiAgICAgICAgICAgIG1hdGNoZXMucHVzaChzdHIuc2xpY2UoZW5kICsgMSkpOwogICAgICAgIH0KICAgIH0KICAgIGVsc2UgewogICAgICAgIHJldHVybiBbXTsKICAgIH0KICAgIHJldHVybiBtYXRjaGVzOwp9Owo="},{"version":3,"file":"/Users/andrewsamboy/Desktop/Git/polymail/webapp/src/lib/matcher.tsx","sourceRoot":"","sources":["/Users/andrewsamboy/Desktop/Git/polymail/webapp/src/lib/matcher.tsx"],"names":[],"mappings":"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","sourcesContent":["import React from 'react';\nimport { typeaheadRegex } from './typeahead';\nimport { CommandControlType } from '@src/types';\nimport { Hotkey } from './hotkeys';\n\n// Returns results of sorted matches\n// ObjectKey is the property of the object that returns the string value to be scored\nexport const sortMatches = (\n  candidates: any[],\n  query: string,\n  objectKey: string,\n): any[] => {\n\n  if (!query) { return candidates; }\n\n  // Create object with scored candidates\n  const scoredCandidates = candidates.map((candidate) => {\n    let score = 0;\n    if (objectKey && candidate[objectKey]) {\n      score = fuzzyMatch(query, candidate[objectKey]);\n    }\n\n    return { candidate, score };\n  });\n\n  const sortedCandidates = scoredCandidates.sort((a, b) => b.score - a.score);\n  return sortedCandidates.map(result => result.candidate);\n};\n\nexport const sortHotkeyMatches = (\n  candidates: Hotkey[],\n  query: string,\n  objectKey: string,\n): any[] => {\n\n  if (!query) { return candidates; }\n\n  // Create object with scored candidates\n  const scoredCandidates = candidates.map((candidate) => {\n    let score = 0;\n    if (objectKey && candidate[objectKey]) {\n      score = fuzzyMatch(query, candidate[objectKey]);\n    }\n\n    // HACK(SHIN): Decrease score for navigation items\n    if (candidate.scope && candidate.scope === CommandControlType.Navigation) {\n      score = score - 10;\n    }\n\n    return { candidate, score };\n  });\n\n  const sortedCandidates = scoredCandidates.sort((a, b) => b.score - a.score);\n  return sortedCandidates.map(result => result.candidate);\n};\n\n// Returns results of sorted matches\n// ObjectKey is the property of the object that returns the string value to be scored\nexport const sortStringMatches = (\n  candidates: any[],\n  query: string,\n): any[] => {\n\n  if (!query) { return candidates; }\n\n  // Create object with scored candidates\n  const scoredCandidates = candidates.map((candidate) => {\n    let score = 0;\n    score = fuzzyMatch(query, candidate);\n    return { candidate, score };\n  });\n\n  const sortedCandidates = scoredCandidates.sort((a, b) => b.score - a.score);\n  return sortedCandidates.map(result => result.candidate);\n};\n\n// Score consts\nconst adjacency_bonus = 100;                // bonus for adjacent matches\nconst separator_bonus = 50;               // bonus if match occurs after a separator\nconst leading_letter_penalty = -0.5;        // penalty every letter in str before the first match\nconst max_leading_letter_penalty = -1;    // maximum penalty for leading letters\nconst unmatched_letter_penalty = -1;      // penalty for every letter that doesn't matter\n\n// Returns [score]\n// score: integer; higher is better match. Value has no intrinsic meaning.\n// Range varies with pattern. Can only compare scores with same search pattern.\n// Vendored from https://github.com/forrestthewoods/lib_fts\n// TODO(SHIN): There is a new vendored version we probably want to update to that uses recursion\nfunction fuzzyMatch(pattern: string, str: string): number {\n  // Loop variables\n  let score = 0;\n  let patternIdx = 0;\n  const patternLength = pattern.length;\n  let strIdx = 0;\n  const strLength = str.length;\n  let prevMatched = false;\n  let prevSeparator = true;       // true so if first letter match gets separator bonus\n  let prevSeparatorIndex = 0;\n\n  // Use \"best\" matched letter if multiple string letters match the pattern\n  let bestLetter = null;\n  let bestLower = null;\n  let bestLetterIdx = null;\n  let bestLetterScore = 0;\n\n  const matchedIndices: number[] = [];\n\n  // Loop over strings\n  while (strIdx !== strLength) {\n    const patternChar = patternIdx !== patternLength ? pattern.charAt(patternIdx) : null;\n    const strChar = str.charAt(strIdx);\n\n    const patternLower = patternChar != null ? patternChar.toLowerCase() : null;\n    const strLower = strChar.toLowerCase();\n\n    const nextMatch = patternChar && patternLower === strLower;\n    const rematch = bestLetter && bestLower === strLower;\n\n    const advanced = nextMatch && bestLetter;\n    const patternRepeat = bestLetter && patternChar && bestLower === patternLower;\n    if (advanced || patternRepeat) {\n      score += bestLetterScore;\n      if (bestLetterIdx) {\n        matchedIndices.push(bestLetterIdx);\n      }\n      bestLetter = null;\n      bestLower = null;\n      bestLetterIdx = null;\n      bestLetterScore = 0;\n    }\n\n    if (nextMatch || rematch) {\n      let newScore = 0;\n\n      // Apply penalty for each letter before the first pattern match\n      // Note: std::max because penalties are negative values. So max is smallest penalty.\n      if (patternIdx === 0) {\n        const penalty = Math.max(strIdx * leading_letter_penalty, max_leading_letter_penalty);\n        score += penalty;\n      }\n\n      // Apply bonus for consecutive bonuses\n      if (prevMatched) {\n        newScore += adjacency_bonus;\n      }\n\n      // Apply bonus for matches after a separator\n      if (prevSeparator) {\n        if (prevSeparatorIndex > 0) {\n          newScore += (separator_bonus + 1 / prevSeparatorIndex);\n        } else {\n          newScore += (separator_bonus * 3);\n        }\n      }\n\n      // Update patter index IFF the next pattern letter was matched\n      if (nextMatch) {\n        patternIdx += 1;\n      }\n\n      // Update best letter in str which may be for a \"next\" letter or a \"rematch\"\n      if (newScore >= bestLetterScore) {\n        // Apply penalty for now skipped letter\n        if (bestLetter != null) {\n          score += unmatched_letter_penalty;\n        }\n\n        bestLetter = strChar;\n        bestLower = bestLetter.toLowerCase();\n        bestLetterIdx = strIdx;\n        bestLetterScore = newScore;\n      }\n\n      prevMatched = true;\n    } else { // Append unmatch characters\n      score += unmatched_letter_penalty;\n      prevMatched = false;\n    }\n\n    // Includes \"clever\" isLetter check.\n    prevSeparator = strChar === '_' || strChar === ' ' || strChar === '/';\n    prevSeparatorIndex = strIdx;\n\n    strIdx += 1;\n  }\n\n  // Apply score for last match\n  if (bestLetter && bestLetterIdx) {\n    score += bestLetterScore;\n  }\n\n  // Add 1000 if score includes an exact match in the string\n  if (str.toLowerCase().includes(pattern)) {\n    score += 500;\n  }\n\n  return score;\n}\n\nexport const fuzzyFormattedString = (\n  pattern: string, str: string, keyIdx: number|undefined,\n): Array<string|JSX.Element> => {\n  const sanitizedPattern = pattern.replace(/\\s+/g, '');\n  const regex = typeaheadRegex(sanitizedPattern);\n  const match = str.match(regex);\n  let matches: Array<string|JSX.Element> = [];\n\n  if (sanitizedPattern.length && match && match.length > 0) {\n    const titleLowercase = str.toLowerCase();\n    const sanitizedPatternLowercase = sanitizedPattern.toLowerCase();\n    let start = 0;\n    let end = titleLowercase.indexOf(sanitizedPatternLowercase[0]);\n    matches = [\n      str.slice(start, end),\n      <strong key={`${keyIdx}-strong`}>{str[end]}</strong>,\n    ];\n\n    for (let i = 1; i < sanitizedPattern.length; i += 1) {\n      start = end + 1;\n      end = titleLowercase.indexOf(sanitizedPatternLowercase[i], start);\n      matches.push(str.slice(start, end));\n      matches.push(<strong>{str[end]}</strong>);\n    }\n\n    if (end !== str.length - 1) {\n      matches.push(str.slice(end + 1));\n    }\n  } else {\n    return [];\n  }\n\n  return matches;\n};\n"]}]}